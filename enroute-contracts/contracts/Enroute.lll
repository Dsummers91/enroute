;;; Enroute/Identity contract In LLL!
;;; Combining both contracts into one file to not worry about CALL opcode shenanigans, ya feel me

(seq

  ;; Memory Locations
  (def '*scratch1* 0x00)
  (def '*scratch2* 0x20)
  (def '*scratch3* 0x40)
  (def '*funcid*   0x60)

  ;; Storage Locations
  (def '*owner*            0x00)
  
  ;; Function Hashes
  (def '*confirm-shipment*       0xb60f3ec6) ;; confirmShipment(bytes32)
  (def '*can-ship*               0x8da5cb5b) ;; owner()
  (def '*shipments*              0xd87b4041) ;; shipments(bytes32) 
  (def '*access*                 0x6d43c4c9) ;; access(bytes32)
  (def '*get-access*             0x42082e50) ;; getAccess(address,address,uint256)
  (def '*interfaces*             0xd01e14ce) ;; interfaces(address)
  (def '*owner*                  0x8da5cb5b) ;; owner()
  (def '*set-access*             0x082f9065) ;; setAccess(address,address,bool,uint256)
  (def '*set-address-interface*  0x7cc7378c) ;; setAddressInterface(address,bytes4)


  ;; Shifts the leftmost 4 bytes of a 32-byte number right by 28 bytes.
  (def 'shift-right (input)
    (div input (exp 2 224)))

  ;; Gets the function ID and stores it in memory for reference.
  (def 'get-function-id
    (mstore *funcid* (shift-right (calldataload 0x00))))

  (def 'function (function-hash code-body)
    (when (= (mload *funcid*) function-hash)
      code-body))

  (when(callvalue)
    (panic))
  (sstore *owner* (caller))

)
